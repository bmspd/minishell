Мини-оболочка

Прекрасна как ракушка (Гыыыыы !!!!)

Резюме:
Цель этого проекта - создать простую оболочку. Да ваш маленький баш или зш. Вы узнаете много нового о процессах и файловых дескрипторах.

_______________________________________________________________________

Глава I

Вступление

Существование оболочек связано с самим существованием ИТ. В то время все кодировщики согласились, что общение с компьютером с использованием выровненных переключателей 1/0 серьезно раздражает. Было вполне логично, что им пришла в голову идея общаться с компьютером, используя интерактивные строки команд на языке, несколько близком к английскому.

С Minishell вы сможете путешествовать во времени и возвращаться к проблемам, с которыми люди сталкивались, когда Windows еще не существовало.
-------------------------------------------------------------------------

Глава II.

Общие инструкции

• Ваш проект должен быть написан в соответствии с Нормой. Если у вас есть бонусные файлы / функции, они включаются в проверку нормы, и вы получите 0, если внутри есть ошибка нормы.

• Ваши функции не должны завершаться неожиданно (ошибка сегментации, ошибка шины, двойное освобождение и т. Д.), За исключением неопределенного поведения. Если это произойдет, ваш проект будет считаться нефункциональным и получит 0 во время оценки.

• Все пространство памяти, выделенное кучей, должно быть должным образом освобождено при необходимости. Утечки недопустимы.

• Если субъект требует этого, вы должны отправить Makefile, который скомпилирует ваши исходные файлы в требуемый вывод с флагами -Wall, -Wextra и -Werror, и ваш Makefile не должен повторно связываться.

• Ваш Makefile должен содержать как минимум правила $ (NAME), all, clean, fclean и re.

• Чтобы превратить бонусы в свой проект, вы должны включить бонус правила в свой Makefile, который добавит все различные заголовки, библиотеки или функции, запрещенные в основной части проекта. Бонусы должны быть в другом файле _bonus. {C / h}. Оценка обязательной и бонусной части проводится отдельно.

• Если ваш проект позволяет вам использовать ваш libft, вы должны скопировать его исходный код и связанный с ним Makefile в папку libft с соответствующим Makefile. Makefile вашего проекта должен скомпилировать библиотеку, используя свой Makefile, а затем скомпилировать проект.

• Мы рекомендуем вам создавать программы тестирования для вашего проекта, даже если эту работу не нужно будет отправлять и оценивать. Это даст вам возможность легко проверить свою работу и работу коллег. Вы найдете эти тесты особенно полезными во время защиты. Действительно, во время защиты вы можете использовать свои тесты и / или тесты партнера, которого вы оцениваете.

• Отправьте свою работу в назначенный репозиторий git. Оцениваться будет только работа в репозитории git. Если DeepThreadt назначен для оценки вашей работы, это будет сделано после ваших оценок коллег. Если во время выставления оценок Deep Threatt в каком-либо разделе вашей работы произойдет ошибка, оценка будет остановлена.

_______________________________________________________________________________________

Глава III

Обязательная часть

Program name:		minishell
Turn in files:
Makefile:			Yes
Arguments:
External functs.:
{ readline, rl_on_new_line, rl_replace_line,
rl_redisplay, add_history, printf, malloc, free,
write, open, read, close, fork, wait, waitpid,
wait3, wait4, signal, kill, exit, getcwd, chdir,
stat, lstat, fstat, unlink, execve, dup, dup2,
pipe, opendir, readdir, closedir, strerror, errno,
isatty, ttyname, ttyslot, ioctl, getenv, tcsetattr,
tcgetattr, tgetent, tgetflag, tgetnum, tgetstr,
tgoto, tputs }
Libft authorized:	Yes
Description:		Write a shell


Ваша оболочка должна:
• Не интерпретировать незакрытые кавычки или неуказанные специальные символы, такие как \ или ;.

• Не используйте более одной глобальной переменной, подумайте об этом и будьте готовы объяснить, почему вы это делаете.

• Показывать подсказку при ожидании новой команды.

• Иметь рабочую историю.

• Найдите и запустите правильный исполняемый файл (на основе переменной PATH или с использованием относительного или абсолютного пути)

• Он должен реализовывать встроенные функции:
	◦ echo с опцией -n
	◦ cd только с относительным или абсолютным путем
	◦ pwd без параметров
	◦ export без параметров
	◦ unset без параметров
	◦ env без параметров или аргументов
	◦ выйти без параметров

• ’запрещать любую интерпретацию последовательности символов.

• "запретить любую интерпретацию последовательности символов, кроме $.

• Перенаправления:
	◦ < должен перенаправлять ввод.
	◦ > должен перенаправлять вывод.
	◦ «<<» считывать ввод из текущего источника до тех пор, пока не будет видна строка, содержащая только разделитель. не нужно обновлять историю!
	◦ «>>» должен перенаправлять вывод в режиме добавления.

• Трубы | Выход каждой команды в конвейере подключен через канал к
ввод следующей команды.

• Переменные среды ($, за которыми следуют символы) должны раскрыться до своих значений.

• $? должен расшириться до статуса выхода последнего выполненного переднего плана
трубопровод.

• ctrl-C ctrl-D ctrl- \ должно работать как в bash.

• В интерактивном режиме:
	◦ ctrl-C печатает новое приглашение на новой строке.
	◦ ctrl-D выйти из оболочки.
	◦ ctrl- \ ничего не делать.

Не требуется ничего, о чем не спрашивали.
По каждому пункту, если у вас есть сомнения, используйте bash в качестве справочника.

----------------------------------------------------------------------------------------------------------

Глава IV.

Бонусная часть

• Если обязательная часть не идеальна, даже не думайте о бонусах.

• &&, || со скобками для обозначения приоритетов.

• wilcard * должен работать для текущего рабочего каталога
